#+STARTUP: showall
#+STARTUP: hidestars
#+STARTUP: indent
#+PROPERTY: header-args :tangle yes :exports code

* Emacs Configuration

This is my first attempt for actual
[[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]].
The following org file (=~/.emacs.d/emacs-init.org=)
contains all the necessary configuration elisp code
to setup Emacs to my convenience.

To actually load it,
add the following lines
to your =~/.emacs.d/init.el= file:

#+name: init.el content to load the literate configuration
#+begin_src emacs-lisp :tangle no
;; Require org mode
(require 'org-install)
(require 'ob-tangle)

;; Load the custom configuration file
(org-babel-load-file "emacs-init.org"
#+end_src

* Custom File

Emacs stores some custom settings
by default in the init file.
We want to change this
so that the custom settings
are stored inside this file

#+name: Custom variables configuration
#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src

* Required Packages

The packages of this installation
will be installed from the famous
[[http://melpa.org/][MELPA]] Package Repository.

To install packages from there,
the repositories URL
has to be configured:

#+name: MELPA configuration
#+begin_src emacs-lisp
(require 'package)
(setq package-user-dir "~/.emacs.d/elpa/")

(add-to-list 'package-archives
             '("melpa" .
               "http://melpa.milkbox.net/packages/"))

(package-initialize)
#+end_src

The following table
contains a list of all packages
that will be automatically installed
by this configuration on emacs boot:

#+name: packages
| Type  | Package         | Description                                       |
|-------+-----------------+---------------------------------------------------|
| util  | magit           | Exceptional git integration                       |
| util  | undo-tree       | Better undo visualization and handling            |
| util  | helm            | Exceptional completion system                     |
| util  | helm-projectile | helm integration with projectile                  |
| theme | solarized-theme | A very pleasing theme, gently to the stressed eye |

#+begin_src emacs-lisp :var package-entries=packages
(defun jakob-get-package-name (package-entry)
  (intern (cadr package-entry)))

(defun jakob-package-is-installed (package)
  (package-installed-p package))

(defun jakob-install-missing-package (package)
  "Refresh index and install given package"
  (package-refresh-contents)
  (package-install package))

(defun jakob-install-missing-packages ()
  "Install all configured packages."
  (interactive)
  (mapc #'(lambda (package-entry)
            (let
                ((package (jakob-get-package-name package-entry)))
              (unless (jakob-package-is-installed package)
                (jakob-install-missing-package package))))
        (cddr package-entries)))

(jakob-install-missing-packages)
#+end_src

To nicely configure settings
that depend on different packages,
the following macro is defined.
The idea is taken
from this[[http://milkbox.net/note/single-file-master-emacs-configuration/][
blog post]].

#+name: Configuration macro for package related stuff
#+begin_src emacs-lisp
(defmacro after (mode &rest body)
  "`eval-after-load' MODE evaluate BODY."
  (declare (indent defun))
  `(eval-after-load ,mode
     '(progn ,@body)))
#+end_src

It can be used
in two ways.
The following two code example
configure the theme
of emacs and can be used
as examples
for the =after= macro:

** Configuration if package is installed

To execute code
as soon as a package is installed
you can use the
=autoloads= file hook
generated by Emacs:

#+name: Example of executing code only if package is installed
#+begin_src emacs-lisp :tangle no
;; Require solarized if installed
(after "solarized-theme-autoloads"
  (require 'solarized-theme))
#+end_src

** Configuration if package is required or autoloaded

To execute commands
only if a package was actually required
use the name of the package
as first argument to =after=:

#+name: Example of executing code only if package is required
#+begin_src emacs-lisp :tangle no
;; Define solarized light theme if solarized was required
(after "solarized-theme"
  (load-theme 'solarized-light t))
#+end_src

* Generic Display settings

The default Emacs GUI
is rather unappealing to the modern eye.
And since the editor
is focused on keyboard shortcuts
a sophisticated GUI interface is not needed:

#+name: Disable most of the GULi elements
#+begin_src emacs-lisp
;; Turn off mouse interface early in startup to avoid momentary display
(when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

;; No splash screen please... jeez
(setq inhibit-startup-screen t)
#+end_src

A larger monospace font
is especially nice
for longer coding sessions:

#+name: Set a readable default font
#+begin_src emacs-lisp
;; Set default font
(set-default-font "DejaVu Sans Mono")
(set-face-attribute 'default nil :height 120)
#+end_src

In addition to this
the following default theme
should be used:

#+name: Load favorite theme
#+begin_src emacs-lisp
;; Load theme if installed
(after "darcula-theme-autoloads"
  (load-theme 'solarized-light t))
#+end_src

* Org Mode Settings

Org mode is not only used
to build this specific file.
I also use it
for note taking
and TODO management
or small documents.

It should treat source blocks
with the actual major mode:

#+name: Display org-mode source blocks naturally
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
(setq org-edit-src-content-indentation 0)
(setq org-src-tab-acts-natively t)
#+end_src

* Text Mode Settings

** Fix for DOuble CApitalization

Code segment is inspired
by this
[[http://endlessparentheses.com/fixing-double-capitals-as-you-type.html][blog post]].

#+name: Function and a minor mode to enable double capitalization errors
#+begin_src emacs-lisp
(defun dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
       (save-excursion
         (and (if (called-interactively-p)
                  (skip-syntax-backward "w")
                (= -3 (skip-syntax-backward "w")))
              (let (case-fold-search)
                (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
              (capitalize-word 1)))))

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'. Triggers dcaps-to-scaps."
  :init-value nil
  :lighter (" DC")
  (if dubcaps-mode
      (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))
#+end_src

The mode shall be enabled
for text mode
so that it is available
to every text related buffer

#+name: Enable double capitalization mode
#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'dubcaps-mode)
#+end_src

** Show Aiding Symbols

To simplify working
with text files and/or source code
whitespace characters and lines longer the 80 chars
should be made visible:

#+name: Enable whitespace mode for all buffers
#+begin_src emacs-lisp
(require 'whitespace)
(add-hook 'text-mode-hook #'whitespace-mode)
#+end_src

* Helm Settings

Helm is a very powerful and versatile environment
which enables nice completions everywhere.

#+name: test
#+begin_src emacs-lisp
(after "helm-projectile-autoloads"
  (global-set-key (kbd "C-x SPC") 'helm-projectile))
#+end_src

* Magit Settings

#+name: test
#+begin_src emacs-lisp
(after "magit-autoloads"
  (global-set-key (kbd "C-x g") 'magit-status))
#+end_src

* Spell Check Settings

Spell checking will be done by the tool aspell.

#+name: Set aspell to be the default spelling tool
#+begin_src emacs-lisp
(setq ispell-program-name "aspell"
      ispell-extra-args '("--sug-mode=ultra"
                          "--run-together"
                          "--run-together-limit=5"
                          "--run-together-min=2"))
#+end_src

Because I am frequently writing in German and in English
I want a convenient function to efficiently switch between the both:

#+begin_src emacs-lisp
(let ((langs '("english" "german8")))
  (setq lang-ring (make-ring (length langs)))
  (dolist (elem langs) (ring-insert lang-ring elem)))

(defun jakob/cycle-ispell-languages ()
  (interactive)
  (let ((lang (ring-ref lang-ring -1)))
    (ring-insert lang-ring lang)
    (ispell-change-dictionary lang)))
#+end_src

In addition I do want some convenient mappings for spell correction:

#+name: Set spell correction bindings and enable spell check for texts
#+begin_src emacs-lisp
(defun jakob/spell-key-bindings ()
  (global-set-key [f6] 'jakob-cycle-ispell-languages)
  (global-set-key [f7] 'ispell-buffer))
(eval-after-load 'flyspell
  #'jakob/spell-key-bindings)
#+end_src

Finally, enable the flyspell mode

#+name: Enable spell checking for all text files
#+begin_src emacs-lisp
(add-hook 'text-mode-hook
          (lambda () (flyspell-mode 1)))
#+end_src
